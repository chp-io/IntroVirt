/*
 * Copyright 2021 Assured Information Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This file is automatically generated. Do not edit. */
#pragma once

#include "{{ parent_name }}Impl.hh"

#include <introvirt/windows/kernel/{{ namespace }}/syscall/{{ className }}.hh>
#include <introvirt/core/exception/VirtualAddressNotPresentException.hh>

{%- block includes %}
#include <introvirt/core/event/ThreadLocalEvent.hh>
{%- for path in impl_includes %}
#include {{ path }}
{%- endfor %}

// System call injection includes
#include "windows/injection/syscall.hh"
#include "core/injection/RegisterGuard.hh"
#include <introvirt/core/exception/SystemCallInjectionException.hh>
#include <introvirt/windows/event/WindowsEvent.hh>
#include <introvirt/windows/exception/InvalidSystemCallConfiguration.hh>

#include <cstdint>
#include <memory>
#include <ostream>
{%- endblock includes %}

namespace introvirt {
namespace windows {
namespace {{ namespace }} {

template<typename PtrType, typename _BaseClass = {{className}}>
class {{ className }}Impl {{ 'final ' if not has_children }}: public {{ parent_name }}Impl<PtrType, _BaseClass> {
  public:
{%- if arguments %}
{%- block getters %}
    /* Direct parameter getters */

{%- for arg in arguments %}
    {{ arg['type'] if not arg.get('pointer') else 'GuestVirtualAddress' }} {{arg['functionName']}}() const override {{ 'final ' if has_children }} {
        {%- if not arg.get('pointer') and arg['rawType'] != arg['type'] %}
        return static_cast<{{ arg['type'] }}>({{ arg['variableName'] }}_);
        {%- else %}
            {%- if arg['original_type'] == 'HANDLE' and not arg['pointer'] %}
        if (!IS_SELF_HANDLE<PtrType>({{ arg['variableName'] }}_))
           return {{ arg['variableName'] }}_ & HANDLE_MASK;      
            {%- endif %}  
        return {{ arg['variableName'] }}_;
        {%- endif %}    
    }
{%- endfor %}
{%- endblock %}
{%- block setters %}

    /* Direct parameter setters */
    
{%- for arg in arguments %}
    void {{arg['functionName']}}({{ arg['type'] if not arg.get('pointer') else 'const GuestVirtualAddress&' }} {{arg['variableName']}}) override {{ 'final ' if has_children }} {
   {%- if 'conditional_indexes' in arg %}
            {%- set indexVar = '' + arg['indexVar'] %}
        {%- else %}
            {%- set indexVar = arg['index'] %}
        {%- endif %}
        {%- if arg.get('pointer') %}
    this->set_argument({{indexVar}}, {{arg['variableName']}}.virtual_address());
        {%- elif not arg.get('pointer') and arg['rawType'] != arg['type'] %}
    this->set_argument({{indexVar}}, static_cast<{{arg['rawType']}}>({{arg['variableName']}}));
        {%- else %}
    this->set_argument({{indexVar}}, {{arg['variableName']}});
        {%- endif %}
        {%- if not arg.get('pointer') and arg['rawType'] != arg['type'] %}
    {{arg['variableName']}}_ = static_cast<{{arg['rawType']}}>({{arg['variableName']}});
        {%- else %}
    {{arg['variableName']}}_ = {{arg['variableName']}};
        {%- endif %}
        {%- if arg.get('pointer') and 'helper' in arg %}
            {%- if arg['helper']['mode'] != 'copy' %}
    {{arg['name']}}_.reset();
            {%- else %}
    has{{arg['name']}}_ = false;
            {%- endif %}
        {%- endif %}    
    }
{%- endfor %}
{%- endblock %}

{%- block helpers %}

/* Helpers */
    {%- for arg in arguments %}
    {%- if arg['override_helper'] or not arg['override'] %}
        {%- if arg.get('pointer') and 'helper' in arg %}
{% include 'includes/helper_' + arg['helper']['mode'] + '.tpl' %}
        {%- endif %}
    {%- endif %}
    {%- endfor %}{# for arg in arguments #}
{%- endblock helpers %}
{%- endif %}

{% block overrides %}
void write(std::ostream& os) const override {
    {{ parent_name }}Impl<PtrType, _BaseClass>::write(os);
    boost::io::ios_flags_saver ifs(os);
{%- block write %}

{%- if return_type != "NTSTATUS" and return_type != "void" %}    
    os << '\t' << "Result: ";
    if (this->has_returned())
        os << result() << '\n';
    else
        os << "Unavailable\n";
{%- endif %}

{%- for arg in arguments %}
{% if not arg['override'] %}
    os << '\t' << "{{arg['name']}}: ";
{%- if arg.get('pointer') %}
    os << "[" << {{arg['functionName']}}() << {{ '"] "' if 'helper' in arg and arg['writeMethod'] != 'write' else '"]\\n"' }};
{%- else %}
{% include 'includes/write_' + arg['writeMethod'] + '.tpl' %}
{%- endif %}
{%- if 'helper' in arg %}
{%- if arg.get('pointer') %}
    try {
    {%- if arg['helper']['mode'] == 'direct' or arg['helper']['mode'] == 'copy' %}
        if ({%- if arg.get('out') and not arg.get('in') %}this->success() && {% endif %}{{arg['functionName']}}())
    {%- elif arg['helper']['mode'] == 'complex' %}
        if ({%- if arg.get('out') and not arg.get('in') %}this->success() && {% endif %}{{arg['name']}}())
    {%- endif %}
        {% include 'includes/write_helper_' + arg['writeMethod'] + '.tpl' %}
{%- if arg['writeMethod'] != 'write' %}
        else
            os << '\n';
{%- endif %}
    } catch (TraceableException& ex) {
        os << "Unreadable <" << ex.what() << ">\n";
    }
{%- endif %}
{%- endif %}
{%- endif %}
{%- endfor %}
{%- endblock write %}
}

{% if return_type != "NTSTATUS" and return_type != "void" %}
    {{ return_type }} result() const override {
        return static_cast<{{ return_type }}>(this->raw_return_value());
    }

    void result({{ return_type }} value) override {
         this->raw_return_value(static_cast<uint64_t>(value));
     }
{% endif %}

{% if success_check %}
    bool success() const {
        return {{ success_check }};
    }
{% else %}
    bool success() const {
        return this->result().NT_SUCCESS();
    }
{% endif %}

{%- if has_unique_arguments %}
Json::Value json() const override {
    Json::Value r = {{ parent_name }}Impl<PtrType, _BaseClass>::json();
{%- block json %}
    Json::Value& args = r["arguments"];
{%- for arg in arguments %}
{%- if not arg['override'] %}
    Json::Value {{arg['name']}}Json;
{%- if not arg.get('pointer') %}
{% include 'includes/json_' + arg['writeMethod'] + '.tpl' -%}
{%- endif %}
{%- if arg.get('pointer') and 'helper' in arg %}
    {%- if arg['helper']['mode'] == 'direct' or arg['helper']['mode'] == 'copy' %}
    if ({%- if arg.get('out') and not arg.get('in') %}this->success() && {% endif %}{{arg['functionName']}}())
    {%- elif arg['helper']['mode'] == 'complex' %}
    if ({%- if arg.get('out') and not arg.get('in') %}this->success() && {% endif %}{{arg['name']}}())
    {%- endif %}
    {% include 'includes/json_helper_' + arg['writeMethod'] + '.tpl' %}
{%- endif %}
{%- if arg.get('pointer') %}
    {{arg['name']}}Json["address"] = {{arg['functionName']}}();
{%- endif %}
    args["{{arg['name']}}"] = std::move({{arg['name']}}Json);
{%- endif %}
{% endfor %}

{%- endblock json %}
    return r;
}
{%- endif -%}
{%- endblock %}

{% if not helper_base and not skip_injector %}
    static {{ return_type }} inject({% for arg in signature %}
        {%- if arg.get('pointer') -%}
            {%- if arg.get('use_address_for_injection') -%}
            const GuestVirtualAddress& {{ arg['variableName'] -}}
            {%- elif 'helper' in arg -%}
            {{ 'const ' if not arg.get('out') }}{{ arg['helper']['type'] }}{{'*' if arg.get('optional') else '&'}}
            {{- ' ' -}}
            {{ arg['name'] -}}
            {%- else -%}
            const GuestVirtualAddress& {{ arg['variableName'] -}}
            {%- endif -%}
        {%- else -%}
            {%- if arg['type'] == 'VOID' %}
                {#- TODO: Replace this if we add an abstraction for pointers besides uint64_t -#}
                {{- 'uint64_t' -}}
            {% else %}
                {{- arg['type'] -}}
            {% endif %}

            {{- ' ' -}}
            {{ arg['variableName'] if arg.get('pointer') else arg['name'] -}}
        {%- endif -%}

        {%- if not loop.last %}, {% endif -%}
    {%- endfor %}) {
    auto& event = static_cast<WindowsEvent&>(ThreadLocalEvent::get());    
    
    {# Figure out the additional stack space required #}
    {%- set count = [0] %}
    {%- for arg in signature %}
        {%- if arg.get('pointer') %}
            {%- if 'helper' in arg and arg['helper']['mode'] != 'complex'  %}
                {%- if count.append(count.pop() + 1) %}{% endif %}
            {%- endif %}
        {%- endif %}
    {%- endfor %}

    static constexpr unsigned int additional_stack = {{ count[0] }} * sizeof(PtrType);

    inject::SystemCallInjector<PtrType> injector(event, SystemCallIndex::{{name}}, {{ (signature|length) }}, additional_stack);

        // Create a system call stack frame
    {%- if count[0] > 0 %}
    const uint64_t rsp = injector.stack_pointer();
    {% endif %}

        // Declare pointers to "complex" object types
    {%- for arg in signature %}
        {%- if arg.get('pointer') %}
            {%- if 'helper' in arg %}
                {%- if arg['helper']['mode'] == 'complex' %}
                    {%- if not arg.get('use_address_for_injection') %}
    GuestVirtualAddress {{ arg['variableName'] }};
                    {%- endif %}
                {%- endif %}
            {%- endif %}
        {%- endif %}
    {%- endfor %}

    // Local variables where we can get results back
    {%- set count = [0] %}
    {%- for arg in signature %}
        {%- if arg.get('pointer') %}
            {%- if 'helper' in arg and arg['helper']['mode'] != 'complex'  %}
            {%- if count.append(count.pop() + 1) %}{% endif %}
            {%- if arg.get('optional') %}
    const GuestVirtualAddress {{ arg['variableName'] }}(({{arg['name']}}) ? (rsp - ({{ count[0] }} * sizeof(PtrType))) : 0);
            {%- else %}
    const GuestVirtualAddress {{ arg['variableName'] }}(rsp - ({{ count[0] }} * sizeof(PtrType)));
            {%- endif %}
            {%- endif %}
        {%- endif %}
    {%- endfor %}

    // Create the handler for injection    
    {{ namespace }}::{{ className }}Impl<PtrType> handler(event,
    {%- for arg in signature %}
        {%- if arg.get('pointer') %}
            {%- if 'helper' in arg and arg['helper']['mode'] != 'complex' %}
                {{- ' ' }}{{- arg['variableName'] }}
            {%- else %}
                {{- ' ' }} {{- arg['variableName'] -}}
            {%- endif %}
        {%- else %}
    {{- ' ' }}{{- arg['variableName'] }}
        {%- endif %}
    {{- ',' if not loop.last -}}
    {%- endfor -%}
        );

    // Set input arguments
    {%- for arg in signature %}
        {%- if arg.get('pointer') %}
            {%- if 'helper' in arg %}
                {%- if arg['helper']['mode'] != 'complex' %}
                    {%- if arg.get('optional') %}
    if ({{arg['name']}})
        handler.{{ arg['name' ] }}(*{{ arg['name'] }});
                    {%- else %}
    handler.{{ arg['name' ] }}({{ arg['name'] }});
                    {%- endif %}
                {%- endif %}
            {%- endif %}
        {%- endif %}
    {%- endfor %}

    {% block prepare_inject %}
    // Execute the system call
    injector.call(handler);
    {% endblock prepare_inject %}

    {%- block handleResult %}
    // Copy output variables back to our caller
        {%- for arg in signature %}
            {%- if arg.get('out') and arg.get('pointer') %}
                {%- if 'helper' in arg %}
                    {%- if arg['helper']['mode'] != 'complex' %}
                    {%- if arg.get('optional') %}
    if ({{arg['name']}})
        *{{ arg['name'] }} = handler.{{ arg['name' ] }}();
                    {%- else %}
    {{ arg['name'] }} = handler.{{ arg['name' ] }}();
                    {%- endif %}
                    {%- endif %}
                {%- endif %}
            {%- endif %}
        {%- endfor %}
    {%- endblock handleResult %}

{%- block cleanup %}
{%- endblock cleanup %}
    
    // Return the result from the call
    return handler.result(); 
    }
{%- endif %}


/* Constructor */
    {{ className }}Impl(WindowsEvent& event) :
        {{ parent_name }}Impl<PtrType, _BaseClass>(event) {
{%- block constructor %}

{%- if has_conditional_indexes %}
{% include 'includes/constructor_arg_switch.tpl' %}
{%- endif %}
{%- for arg in arguments %}
    {%- if 'conditional_indexes' in arg %}
    {%- if arg.get('pointer') %}
    {{arg['variableName']}}_ = GuestVirtualAddress(this->get_argument({{arg['indexVar']}}));
    {%- else %}
    {{arg['variableName']}}_ = this->get_argument({{arg['indexVar']}});
    {%- endif %}
    {%- else %}
    {%- if arg.get('pointer') %}
    {{arg['variableName']}}_ = GuestVirtualAddress(this->get_argument({{arg['index']}}));
    {%- else %}
    {{arg['variableName']}}_ = this->get_argument({{arg['index']}});
    {%- endif %}
    {%- endif %}
{%- endfor %}

{%- for arg in arguments %}
    {%- if 'helper' in arg and arg['helper']['mode'] == 'copy' %}

    try {
        // Try to copy the initial value for {{arg['name']}}
        if({{arg['functionName']}}())
            {{arg['name']}}();
    } catch (VirtualAddressNotPresentException& ex) {
        // Couldn't copy it. We'll try again if someone calls {{arg['name']}}().
    }
    {%- endif %}
{%- endfor %}

{%- endblock %}
    }        
        

  private:
{%- if not helper_base %}
    /* Injection constructor */
    {{ className }}Impl(WindowsEvent& event, {% for arg in signature %}{{ arg['type'] if not arg.get('pointer') else 'const GuestVirtualAddress&' }} {{arg['variableName']}}{% if not loop.last %}, {% endif %}{%- endfor %}) :
        {{ parent_name }}Impl<PtrType, _BaseClass>(event) {

    // Set all of the arguments
{%- for arg in signature %}
    this->{{arg['functionName']}}({{arg['variableName']}});
{%- endfor %}
    }   
{%- endif %}
    /* Direct parameters */
    {%- for arg in arguments %}
    {{ arg['rawType'] if not arg.get('pointer') else 'GuestVirtualAddress' }} {{arg['variableName']}}_;
    {%- endfor %}

    {%- block helper_variables %}
    /* Helper variables */
    {%- if has_helpers %}
        {%- for arg in arguments %}
            {%- if arg.get('pointer') and 'helper' in arg %}
    {% include 'includes/impl_decl_helper_' + arg['helper']['mode'] + '.tpl' %}
            {%- endif %}
        {%- endfor %}
    {%- endif %}
    {% endblock helper_variables %}

    {%- if has_conditional_indexes %}
    /* Variable indexes */
        {%- for arg in arguments %}
    {#- Declare variables #}
            {%- if 'conditional_indexes' in arg %}
    int {{arg['indexVar']}};
            {%- endif %}
        {%- endfor %}
    {%- endif %}
};

{% if not helper_base and not skip_injector %}
{{ return_type }} {{ className }}::inject({% for arg in signature %}
        {%- if arg.get('pointer') -%}
            {%- if arg.get('use_address_for_injection') -%}
            const GuestVirtualAddress& {{ arg['variableName'] -}}
            {%- elif 'helper' in arg -%}
            {{ 'const ' if not arg.get('out') }}{{ arg['helper']['type'] }}{{'*' if arg.get('optional') else '&'}}
            {{- ' ' -}}
            {{ arg['name'] -}}
            {%- else -%}
            const GuestVirtualAddress& {{ arg['variableName'] -}}
            {%- endif -%}
        {%- else -%}
            {%- if arg['type'] == 'VOID' %}
                {#- TODO: Replace this if we add an abstraction for pointers besides uint64_t -#}
                {{- 'uint64_t' -}}
            {% else %}
                {{- arg['type'] -}}
            {% endif %}

            {{- ' ' -}}
            {{ arg['variableName'] if arg.get('pointer') else arg['name'] -}}
        {%- endif -%}

        {%- if not loop.last %}, {% endif -%}
    {%- endfor %}) {

    auto& event = static_cast<WindowsEvent&>(ThreadLocalEvent::get());
    if (event.guest().x64()) {
        return {{ className }}Impl<uint64_t>::inject(
    {% for arg in signature %}
    {%- if arg.get('pointer') -%}
        {%- if arg.get('use_address_for_injection') -%}
        {{ arg['variableName'] -}}
        {%- elif 'helper' in arg -%}        
        {{ arg['name'] -}}
        {%- else -%}
        {{ arg['variableName'] -}}
        {%- endif -%}
    {%- else -%}
        {{ arg['variableName'] if arg.get('pointer') else arg['name'] -}}
    {%- endif -%}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor %}
        );
    } else {
        return {{ className }}Impl<uint32_t>::inject(
    {% for arg in signature %}            
    {%- if arg.get('pointer') -%}
        {%- if arg.get('use_address_for_injection') -%}
        {{ arg['variableName'] -}}
        {%- elif 'helper' in arg -%}        
        {{ arg['name'] -}}
        {%- else -%}
        {{ arg['variableName'] -}}
        {%- endif -%}
    {%- else -%}
        {{ arg['variableName'] if arg.get('pointer') else arg['name'] -}}
    {%- endif -%}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor %}
        );
    }
}
{% endif %}

} /* namespace {{ namespace }} */
} /* namespace windows */
} /* namespace introvirt */

